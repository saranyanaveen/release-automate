name: Generate Release Notes

on:
  push:
    branches:
      - main
  pull_request:
    types:
      - opened
      - reopened
      - synchronize
      - closed

      - closed

jobs:
  draft-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      # Checkout the repository
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          fetch-tags: true

      # Step 1: Increment version dynamically based on commit messages
      - name: Increment Version Based on Commit Messages
        id: increment_version
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"
          VERSION=${LATEST_TAG#v}
          IFS='.' read -r major minor patch <<< "$VERSION"

          # Check commit messages for version bump
          COMMIT_MSG=$(git log -1 --pretty=%B)
          if echo "$COMMIT_MSG" | grep -iqE "BREAKING CHANGE"; then
            major=$((major + 1))
            minor=0
            patch=0
          elif echo "$COMMIT_MSG" | grep -iqE "feat|feature|enhancement|new-feature"; then
            minor=$((minor + 1))
            patch=0
          else
            patch=$((patch + 1))
          fi

          NEW_VERSION="v${major}.${minor}.${patch}"
          echo "New version: $NEW_VERSION"
          echo "::set-output name=new_version::$NEW_VERSION"
          echo "::set-output name=release_date::$(date +'%Y-%m-%d')"

      # Step 2: Categorize pull request data based on labels
      - name: Categorize Pull Request Data
        id: categorize_changes
        run: |
          COMMIT_MESSAGES=$(git log $LATEST_TAG..HEAD --pretty=format:"%h %s %ad" --date=short)
          FEATURES=""
          BUG_FIXES=""
          OTHER_CHANGES=""
          MAINTENANCE=""
          while IFS= read -r commit; do
            COMMIT_DATE=$(echo "$commit" | awk '{print $3}')
            if echo "$commit" | grep -iqE "(feat|enhancement|new-feature)"; then
              FEATURES+="- $commit\n"
            elif echo "$commit" | grep -iqE "(bug|fix|defect)"; then
              BUG_FIXES+="- $commit\n"
            elif echo "$commit" | grep -iqE "(docs|documentation|other)"; then
              OTHER_CHANGES+="- $commit\n"
            elif echo "$commit" | grep -iqE "(chore|refactor|maintenance)"; then
              MAINTENANCE+="- $commit\n"
            fi
          done <<< "$COMMIT_MESSAGES"

          echo "FEATURES=$FEATURES" >> $GITHUB_ENV
          echo "BUG_FIXES=$BUG_FIXES" >> $GITHUB_ENV
          echo "OTHER_CHANGES=$OTHER_CHANGES" >> $GITHUB_ENV
          echo "MAINTENANCE=$MAINTENANCE" >> $GITHUB_ENV

      - name: Generate Release Notes
        run: |
          NEW_VERSION=${{ steps.increment_version.outputs.new_version }}
          RELEASE_DATE=${{ steps.increment_version.outputs.release_date }}

          # Combine release version, date, and categorized changes
          RELEASE_NOTES="# Release $NEW_VERSION - $RELEASE_DATE

          $(cat categorized_changes.md)

          ### Contributors
          $(cat pr_data.json | jq -r '.[].author.login' | sort | uniq | paste -sd ', ')"

          # Save to a markdown file
          echo "$RELEASE_NOTES" > release_notes.md
          echo "Release notes generated: $(cat release_notes.md)"

      # Step 4: Create the release on GitHub
      - name: Publish Draft Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
        with:
          tag_name: "v${NEXT_MAJOR}.${NEXT_MINOR}.${NEXT_PATCH}"
          release_name: "Draft Release v${NEXT_MAJOR}.${NEXT_MINOR}.${NEXT_PATCH}"
          body_path: release_notes.md

          draft: true
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Debug generated release notes
        run: cat release_notes.md
